#!/usr/bin/env bash
# nv - File navigation wrapper for lsd (https://github.com/gabrielmsilva00/nv)
VERSION="0.1.2"
REPO="gabrielmsilva00/nv"
LICENSE="Apache-2.0"
MAINTAINERS=("Gabriel Silva (@gabrielmsilva00)")
NV_URL="https://raw.githubusercontent.com/${REPO}/main/nv"

# --- Colors & formatting ---
BOLD=$(tput bold 2>/dev/null) || BOLD=""
RESET=$(tput sgr0 2>/dev/null) || RESET=""
RED=$(tput setaf 1 2>/dev/null) || RED=""
GREEN=$(tput setaf 2 2>/dev/null) || GREEN=""
YELLOW=$(tput setaf 3 2>/dev/null) || YELLOW=""
BLUE=$(tput setaf 4 2>/dev/null) || BLUE=""
WHITE=$(tput setaf 7 2>/dev/null) || WHITE=""
ESC=$(printf '\033')

# --- Installer Functions ---

self_install() {
    local install_mode="local"
    local need_sudo=false
    local install_dir="$HOME/.local/bin"
    local missing_deps=()

    for arg in "$@"; do
        case "$arg" in
            --root)  install_mode="root"; install_dir="/root/.local/bin"; need_sudo=true ;;
            --usr)   install_mode="usr";  install_dir="/usr/local/bin";   need_sudo=true ;;
            --local) install_mode="local"; install_dir="$HOME/.local/bin"; need_sudo=false ;;
            -h|--help)
                echo "nv self-installer v${VERSION}"
                echo "Usage: nv --self-install [--local | --usr | --root]"
                exit 0
                ;;
        esac
    done

    echo "${BOLD}${BLUE}nv installer${RESET}"
    echo "Target:  $install_dir"
    echo "Repo:    https://github.com/$REPO"
    
    # Check for existing installation
    local existing_nv
    existing_nv=$(command -v nv 2>/dev/null)
    if [[ -n "$existing_nv" ]]; then
        if grep -q "$REPO" "$existing_nv" 2>/dev/null; then
            local current_ver
            current_ver=$(grep "^VERSION=" "$existing_nv" 2>/dev/null | cut -d'"' -f2 || echo "?")
            [[ "$current_ver" == "$VERSION" ]] && {
                echo -n "nv v${VERSION} is already installed. Reinstall? [y/N] "
                read -r -n 1 response 2>/dev/null || response="n"
                [[ ! "$response" =~ ^[yY]$ ]] && { echo; exit 0; }
                echo -e "\n${WHITE}→${RESET} Reinstalling v${VERSION}..."
            } || echo "${WHITE}→${RESET} Updating nv v${current_ver} to v${VERSION}"
        else
            echo "${YELLOW}⚠${RESET} Different 'nv' found at $existing_nv. Installing to $install_dir/nv"
        fi
        echo
    fi

    # Check dependencies
    command -v curl &>/dev/null || missing_deps+=("curl")
    command -v lsd &>/dev/null  || missing_deps+=("lsd")
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        echo "${RED}Missing dependencies:${RESET} ${missing_deps[*]}"
        exit 1
    fi

    # Download
    local tmpfile
    tmpfile=$(mktemp)
    if ! curl -fsSL -H "Cache-Control: no-cache" "$NV_URL" -o "$tmpfile" || \
       ! grep -q "$REPO" "$tmpfile"; then
        echo "${RED}Download failed or corrupted${RESET}"
        rm -f "$tmpfile"
        exit 1
    fi

    # Install
    local install_cmd=("mv" "$tmpfile" "$install_dir/nv")
    [[ "$need_sudo" == true ]] && install_cmd=("sudo" "cp" "$tmpfile" "$install_dir/nv")
    
    if ! mkdir -p "$install_dir" 2>/dev/null || \
       ! "${install_cmd[@]}" 2>/dev/null || \
       ! chmod +x "$install_dir/nv" 2>/dev/null; then
        echo "${RED}✗ Installation failed${RESET}. Try running with sudo or check permissions."
        rm -f "$tmpfile" 2>/dev/null
        exit 1
    fi
    
    rm -f "$tmpfile" 2>/dev/null
    echo "${GREEN}✓${RESET} nv v${VERSION} installed to $install_dir/nv"
    [[ ":$PATH:" != *":$install_dir:"* ]] && echo "${YELLOW}⚠${RESET} $install_dir is not in your PATH."
    
    # Shell Configuration Step
    configure_shells "$install_dir/nv"

    echo -e "\n${GREEN}Done!${RESET} If you configured shells, restart them or run 'source <rcfile>'."
}

configure_shells() {
    local nv_path="$1"
    
    # Define supported shells and their RC files
    # Format: "Name:RC_Path:Type"
    # Type: alias (standard alias), fish (function), nu (nushell alias), csh (csh alias)
    local candidates=(
        "Bash:$HOME/.bashrc:alias"
        "Bash Profile:$HOME/.bash_profile:alias"
        "Zsh:$HOME/.zshrc:alias"
        "Fish:$HOME/.config/fish/config.fish:fish"
        "Ksh:$HOME/.kshrc:alias"
        "Tcsh:$HOME/.tcshrc:csh"
        "Csh:$HOME/.cshrc:csh"
        "Dash/Sh:$HOME/.profile:alias"
        "Nushell:$HOME/.config/nushell/config.nu:nu"
        "Nushell:$HOME/AppData/Roaming/nushell/config.nu:nu"
    )

    local available_indices=()
    local selected=()
    local display_names=()
    local rc_paths=()
    local types=()

    # Detection Phase
    for i in "${!candidates[@]}"; do
        IFS=':' read -r name path type <<< "${candidates[$i]}"
        if [[ -f "$path" ]]; then
            available_indices+=("$i")
            selected+=("true")
            display_names+=("$name")
            rc_paths+=("$path")
            types+=("$type")
        fi
    done

    if [[ ${#available_indices[@]} -eq 0 ]]; then
        echo "${YELLOW}No supported shell configuration files found.${RESET}"
        return
    fi

    # Interactive Phase
    echo -e "\n${BOLD}${BLUE}Shell Configuration${RESET}"
    echo "Nv needs to be aliased in your shell to enable navigation."
    
    while true; do
        echo
        echo "${BOLD}Detected Shells:${RESET}"
        for i in "${!available_indices[@]}"; do
            local idx="${available_indices[$i]}"
            local mark=" "
            [[ "${selected[$i]}" == "true" ]] && mark="${GREEN}✔${RESET}" || mark="${RED}✗${RESET}"
            
            # Shorten path for display
            local short_path="${rc_paths[$i]/$HOME/~}"
            printf "  [%b] %d) %-12s ${WHITE}%s${RESET}\n" "$mark" "$((i+1))" "${display_names[$i]}" "$short_path"
        done
        
        echo
        echo -n "${BOLD}Action [Y/n/select numbers]:${RESET} "
        read -r input
        
        input=$(echo "$input" | tr '[:upper:]' '[:lower:]')
        
        if [[ -z "$input" || "$input" == "y" || "$input" == "yes" ]]; then
            break
        elif [[ "$input" == "n" || "$input" == "no" ]]; then
            echo "${YELLOW}Skipping shell configuration.${RESET}"
            return
        else
            # Toggle logic
            for token in $input; do
                if [[ "$token" =~ ^[0-9]+$ ]]; then
                    # Check range
                    local sel_idx=$((token-1))
                    if (( sel_idx >= 0 && sel_idx < ${#available_indices[@]} )); then
                        if [[ "${selected[$sel_idx]}" == "true" ]]; then
                            selected[$sel_idx]="false"
                        else
                            selected[$sel_idx]="true"
                        fi
                    fi
                fi
            done
        fi
    done

    # Application Phase
    local configured_count=0
    echo
    for i in "${!available_indices[@]}"; do
        if [[ "${selected[$i]}" == "true" ]]; then
            local path="${rc_paths[$i]}"
            local type="${types[$i]}"
            local name="${display_names[$i]}"
            
            echo -n "Configuring $name... "
            
            # Check for existing config
            if grep -q "nv" "$path" 2>/dev/null && \
               (grep -q "alias nv=" "$path" || grep -q "function nv" "$path" || grep -q "def nv" "$path"); then
                echo "${YELLOW}Skipped (already configured)${RESET}"
                continue
            fi

            # Append config based on type
            local config_str=""
            case "$type" in
                fish) config_str="$(printf '\n# nv navigation wrapper\nfunction nv; source "%s" $argv; end' "$nv_path")" ;;
                csh)  config_str="$(printf '\n# nv navigation wrapper\nalias nv "source %s"' "$nv_path")" ;;
                nu)   config_str="$(printf '\n# nv navigation wrapper\ndef --env nv [path: string = "."] { source "%s" $path }' "$nv_path")" ;;
                *)    config_str="$(printf '\n# nv navigation wrapper\nalias nv="source %s"' "$nv_path")" ;;
            esac
            
            if echo "$config_str" >> "$path"; then
                echo "${GREEN}✓${RESET}"
                ((configured_count++))
            else
                echo "${RED}Failed${RESET}"
            fi
        fi
    done
    
    if (( configured_count > 0 )); then
        echo -e "\n${GREEN}Success!${RESET} Restart your shell to apply changes."
    elif [[ "${input}" != "n" ]]; then
        echo -e "\n${YELLOW}No changes made.${RESET}"
    fi
}

perform_self_upgrade() {
    echo "Checking for updates..."
    local tmpfile
    tmpfile=$(mktemp)
    if ! curl -fsSL -H "Cache-Control: no-cache" "$NV_URL" -o "$tmpfile" || \
       ! grep -q "$REPO" "$tmpfile"; then
        echo "${RED}Download failed${RESET}"
        rm -f "$tmpfile"
        exit 1
    fi

    local new_ver
    new_ver=$(grep "^VERSION=" "$tmpfile" | cut -d'"' -f2)
    if [[ "$new_ver" == "$VERSION" ]]; then
         echo "Already on the latest version v${VERSION}."
         rm -f "$tmpfile"
         exit 0
    fi
    
    echo "New version available: $new_ver (Current: $VERSION)"
    echo "Upgrading..."
    
    local install_arg="--local"
    local current_loc
    current_loc=$(command -v nv 2>/dev/null)
    [[ "$current_loc" == "/usr/local/bin/nv" ]] && install_arg="--usr"
    [[ "$current_loc" == "/root/.local/bin/nv" ]] && install_arg="--root"
    
    chmod +x "$tmpfile"
    "$tmpfile" --self-install "$install_arg"
    local ret=$?
    rm -f "$tmpfile"
    exit $ret
}

# --- Core Logic ---

safe_print() {
    local prefix="$1"
    local content="$2"
    local clean_c="$3"
    local cols="${4:-80}"

    local clean_p="${prefix//$'\e'\[[0-9;]*[mK]/}"
    [[ -z "$clean_c" ]] && clean_c="${content//$'\e'\[[0-9;]*[mK]/}"

    # Fast path: print if it fits
    if (( ${#clean_p} + ${#clean_c} <= cols )); then
        echo "${prefix}${content}"
        return
    fi
    
    local avail=$(( cols - ${#clean_p} - 3 ))
    (( avail < 1 )) && avail=1
    
    # Truncate end, keep start
    # Truncate end, keep start
    local truncated_clean="${clean_c:0:$avail}"
    local color_code=""
    
    # Regex in variable to avoid parsing errors
    local re=$'(\e\[[0-9;]*m)'
    if [[ "$content" =~ $re ]]; then
        color_code="${BASH_REMATCH[1]}"
    fi
    
    echo "${prefix}${color_code}${truncated_clean}...${RESET}"
}

run_nv() {
    local dot=0 full=0 depth=2 args=()
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                echo "Usage: nv [options] [directory]"
                echo "  -dt, --dotfiles  Include hidden files"
                echo "  -f,  --full      Disable item capping"
                echo "  -t,  --depth N   Set recursion depth (Default: 2)"
                echo "  --self-upgrade   Update nv"
                exit 0 ;;
            -dt|--dotfiles) dot=1 ;;
            -f|--full) full=1 ;;
            -t|--depth) [[ "$2" =~ ^[0-9]+$ ]] && { depth=$2; shift; } ;;
            *) args+=("$1") ;;
        esac
        shift
    done
    
    # Navigate if args provided
    if [[ ${#args[@]} -gt 0 ]]; then
        builtin cd "${args[@]}" || return
    fi
    
    # Terminal width calculation
    local cols
    cols=$(tput cols 2>/dev/null) || cols=80
    (( cols > 2 )) && cols=$(( cols - 2 ))
    
    # Prepare lsd command
    local cmd=("lsd" "--group-directories-first" "--color=always" "--icon=always")
    local lsd_opts=("${cmd[@]}" "-1")
    [[ $dot -eq 1 ]] && lsd_opts+=("-A")

    # Fetch main directory entries
    local lines_formatted=() lines_plain=() lines_stripped=()
    mapfile -t lines_formatted < <("${lsd_opts[@]}" --color=always --icon=always)
    mapfile -t lines_plain < <("${lsd_opts[@]}" --color=never --icon=never)
    mapfile -t lines_stripped < <(printf "%s\n" "${lines_formatted[@]}" | sed "s/${ESC}\[[0-9;]*[mK]//g")
    
    local m_count=${#lines_plain[@]}
    local s_lim=$(( 12 - (m_count / 2) ))
    (( s_lim < 2 )) && s_lim=2
    (( s_lim > 10 )) && s_lim=10
    
    # Print Root
    safe_print "" "$("${cmd[@]}" -d "../$(basename "$PWD")")" "" "$cols"
    
    if [[ $full -eq 1 ]]; then
        "${cmd[@]}" --tree --depth "$depth" | sed '1d'
        return
    fi
    
    # Iterate and print tree
    for ((i=0; i<m_count; i++)); do
        local entry="${lines_plain[$i]}"
        local entry_fmt="${lines_formatted[$i]}"
        local entry_str="${lines_stripped[$i]}"
        local is_last=0
        [[ $i -eq $((m_count - 1)) ]] && is_last=1
        
        local connector="├── " sub_prefix="│   "
        [[ $is_last -eq 1 ]] && { connector="└── "; sub_prefix="    "; }
        
        if [[ -d "$entry" ]]; then
            safe_print "$connector" "$entry_fmt" "$entry_str" "$cols"
            
            # Sub-entry batching
            local sub_fmt=() sub_str=()
            local limit=$((s_lim + 1))
            
            mapfile -t sub_fmt < <("${lsd_opts[@]}" --color=always --icon=always "$entry" | head -n "$limit")
            mapfile -t sub_str < <(printf "%s\n" "${sub_fmt[@]}" | sed "s/${ESC}\[[0-9;]*[mK]//g")
            
            local s_cnt=${#sub_fmt[@]}
            if (( s_cnt > 0 )); then
                local disp_cnt=$s_lim
                (( s_cnt < s_lim )) && disp_cnt=$s_cnt
                
                for ((j=0; j<disp_cnt; j++)); do
                    local sub_conn="├── "
                    [[ $j -eq $((disp_cnt - 1)) && $s_cnt -le $s_lim ]] && sub_conn="└── "
                    safe_print "$sub_prefix$sub_conn" "${sub_fmt[$j]}" "${sub_str[$j]}" "$cols"
                done
                (( s_cnt > s_lim )) && echo "${sub_prefix}└── ..."
            fi
        else
            safe_print "$connector" "$entry_fmt" "$entry_str" "$cols"
        fi
    done
}

# --- Main Entry Point ---

case "$1" in
    --self-install) self_install "${@:2}"; exit 0 ;;
    --self-upgrade) perform_self_upgrade; exit 0 ;;
esac

(return 0 2>/dev/null) && sourced=1 || sourced=0
if [ "$sourced" -eq 1 ]; then
    run_nv "$@"
else
    # Run in sub-process (will not affect parent shell PWD)
    run_nv "$@"
fi